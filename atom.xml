<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[剑紫青天]]></title>
  <subtitle><![CDATA[三人行，必有我师焉；择其善者而从之，其不善者而改之]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://jzqt.github.io/"/>
  <updated>2016-07-03T11:52:49.747Z</updated>
  <id>http://jzqt.github.io/</id>
  
  <author>
    <name><![CDATA[剑紫青天]]></name>
    <email><![CDATA[561484726@qq.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[SQLAlchemy做关联查询时的filter问题]]></title>
    <link href="http://jzqt.github.io/2016/07/03/SQLAlchemy%E5%81%9A%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E6%97%B6%E7%9A%84filter%E9%97%AE%E9%A2%98/"/>
    <id>http://jzqt.github.io/2016/07/03/SQLAlchemy做关联查询时的filter问题/</id>
    <published>2016-07-03T09:58:08.000Z</published>
    <updated>2016-07-03T11:52:49.747Z</updated>
    <content type="html"><![CDATA[<p>在使用SQLAlchemy的ORM做关联查询filter时出了一点问题，同时也暴露出对SQLAlchemy的DSL的一些漏洞。</p>
<p>现在要查询的Model是<code>Submission</code>，<code>Submission</code>有两个外键<code>submitter_id</code>和<code>problem_id</code>，分别关联<code>User</code>和<code>Problem</code>这两个Model。<br>然后查询时想要对<code>User</code>和<code>Problem</code>的字段做filter。</p>
<p>于是我写成了这样</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">session.query(Submission).options(</span><br><span class="line">    joinedload(<span class="string">"submitter"</span>), joinedload(<span class="string">"problem"</span>)</span><br><span class="line">).filter(User.username == <span class="string">"JZQT"</span>).all()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">session.query(Submission).options(</span><br><span class="line">    joinedload(<span class="string">"submitter"</span>), joinedload(<span class="string">"problem"</span>)</span><br><span class="line">).filter(Problem.remote_pid == <span class="string">"1000"</span>).all()</span><br></pre></td></tr></table></figure>
<p>结果发现查询出来的<code>Submission</code>对象并不满足这些限制条件。<br>生成的SQL语句如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> &#123;Submission, <span class="keyword">User</span>, Problem 的所有字段名&#125;</span><br><span class="line"><span class="keyword">FROM</span> &#123;Submission, Problem 和 <span class="keyword">User</span> 的数据表名&#125;</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> &#123;<span class="keyword">User</span>数据表名&#125; <span class="keyword">ON</span> &#123;<span class="keyword">User</span>.<span class="keyword">id</span> == Submission.submitter_id&#125;</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> &#123;Problem数据表名&#125; <span class="keyword">ON</span> &#123;Problem.<span class="keyword">id</span> == Submission.problem_id&#125;</span><br><span class="line"><span class="keyword">WHERE</span> &#123;<span class="keyword">User</span>.username == <span class="string">"JZQT"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> &#123;Submission, <span class="keyword">User</span>, Problem 的所有字段名&#125;</span><br><span class="line"><span class="keyword">FROM</span> &#123;Submission, Problem 和 <span class="keyword">User</span> 的数据表名&#125;</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> &#123;<span class="keyword">User</span>数据表名&#125; <span class="keyword">ON</span> &#123;<span class="keyword">User</span>.<span class="keyword">id</span> == Submission.submitter_id&#125;</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> &#123;Problem数据表名&#125; <span class="keyword">ON</span> &#123;Problem.<span class="keyword">id</span> == Submission.problem_id&#125;</span><br><span class="line"><span class="keyword">WHERE</span> &#123;Problem.remote_pid == <span class="string">"1000"</span>&#125;</span></span><br></pre></td></tr></table></figure>
<p>实际上这样的SQL造成的效果是这样的</p>
<p>如果数据库中存在<code>username</code>等于<code>&quot;JZQT&quot;</code>的<code>User</code>对象，那么你会查询出所有的<code>Submission</code>。<br>同理，如果数据库中存在<code>remote_pid</code>为<code>&quot;1000&quot;</code>的<code>Problem</code>对象，会查询出所有的<code>Submission</code>。<br>如果不存在，也就是说<code>User</code>或<code>Problem</code>中没有满足where子句条件的对象，那么查询不出来<code>Submission</code>。</p>
<p>这样的SQL查询当然不符合我们的要求。</p>
<p>经过一段时间的琢磨，终于发现了一个符合要求的方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重点在join</span></span><br><span class="line"><span class="comment"># 实际上如果不需要加载外键的Model，仅仅是需要filter的话，options里面的joinedload可以省略</span></span><br><span class="line">session.query(Submission).join(Problem, User).filter(User.username == <span class="string">"JZQT"</span>).all()</span><br><span class="line"></span><br><span class="line">session.query(Submission).join(Problem, User).filter(Problem.remote_pid == <span class="string">"1000"</span>).all()</span><br></pre></td></tr></table></figure>
<p>它生成的SQL语句如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> &#123;Submission, Problem, <span class="keyword">User</span> 的所有字段名&#125;</span><br><span class="line"><span class="keyword">FROM</span> &#123;Submission数据表名&#125;</span><br><span class="line"><span class="keyword">JOIN</span> &#123;Problem的数据表名&#125; <span class="keyword">ON</span> &#123;Problem.<span class="keyword">id</span> == Submission.problem_id&#125;</span><br><span class="line"><span class="keyword">JOIN</span> &#123;<span class="keyword">User</span>的数据表名&#125; <span class="keyword">ON</span> &#123;<span class="keyword">User</span>.<span class="keyword">id</span> == Submission.submitter_id&#125;</span><br><span class="line"><span class="keyword">WHERE</span> &#123;<span class="keyword">User</span>.username == <span class="string">"JZQT"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> &#123;Submission, Problem, <span class="keyword">User</span> 的所有字段名&#125;</span><br><span class="line"><span class="keyword">FROM</span> &#123;Submission数据表名&#125;</span><br><span class="line"><span class="keyword">JOIN</span> &#123;Problem的数据表名&#125; <span class="keyword">ON</span> &#123;Problem.<span class="keyword">id</span> == Submission.problem_id&#125;</span><br><span class="line"><span class="keyword">JOIN</span> &#123;<span class="keyword">User</span>的数据表名&#125; <span class="keyword">ON</span> &#123;<span class="keyword">User</span>.<span class="keyword">id</span> == Submission.submitter_id&#125;</span><br><span class="line"><span class="keyword">WHERE</span> &#123;Problem.remote_pid == <span class="string">"1000"</span>&#125;</span></span><br></pre></td></tr></table></figure>
<p>暂时先用这个了。</p>
<p>从以上可以看出来，<code>joinedload</code>默认是左外连接<code>LEFT OUTER JOIN</code>的。<br>另外，对与SQLAlchemy的联表问题，我理解的不够，有漏洞。<br>数据库SQL其实也不熟悉。</p>
<p>看来还是要好好学习一下才行。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在使用SQLAlchemy的ORM做关联查询filter时出了一点问题，同时也暴露出对SQLAlchemy的DSL的一些漏洞。</p>
<p>现在要查询的Model是<code>Submission</code>，<code>Submission</code>有两个外键<c]]>
    </summary>
    
      <category term="Python" scheme="http://jzqt.github.io/tags/Python/"/>
    
      <category term="SQL" scheme="http://jzqt.github.io/tags/SQL/"/>
    
      <category term="SQLAlchemy" scheme="http://jzqt.github.io/tags/SQLAlchemy/"/>
    
      <category term="程序设计" scheme="http://jzqt.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tornado同步任务异步化]]></title>
    <link href="http://jzqt.github.io/2016/06/28/Tornado%E5%90%8C%E6%AD%A5%E4%BB%BB%E5%8A%A1%E5%BC%82%E6%AD%A5%E5%8C%96/"/>
    <id>http://jzqt.github.io/2016/06/28/Tornado同步任务异步化/</id>
    <published>2016-06-28T02:10:57.000Z</published>
    <updated>2016-06-28T16:44:37.378Z</updated>
    <content type="html"><![CDATA[<p>在<code>Tornado</code>中，要使一个任务，我们经常需要用<code>Tornado</code>自己的异步模块，或者适配<code>Tornado</code>的第三方异步模块。</p>
<p>但很多情况下我们需要的功能模块可能没有适配<code>Tornado</code>的异步模型，然后我们自己又不可能造一个轮子。<br>这个时候，我们就可以使用<code>Tornado</code>自带的通过线程来将同步方法异步化。</p>
<p>虽然<code>Tornado</code>是单线程异步的Web框架，但是它也提供了使用线程来将同步任务异步化的装饰器。</p>
<p>在<code>tornado.concurrent</code>这个模块中有一个装饰器<code>run_on_executor</code>，使用它装饰在请求处理器的方法上，来使用线程将该同步任务异步话。</p>
<p>下面给出示例代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"><span class="keyword">import</span> tornado.concurrent</span><br><span class="line"><span class="keyword">import</span> tornado.ioloop</span><br><span class="line"><span class="keyword">import</span> tornado.gen</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 要求请求处理器有一个`executor`属性表示异步执行器</span></span><br><span class="line">    <span class="comment"># 创建一个size为4的线程池执行器</span></span><br><span class="line">    executor = concurrent.futures.ThreadPoolExecutor(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="decorator">    @tornado.gen.coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        futures = [self.sleep(<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>)]</span><br><span class="line">        results = <span class="keyword">yield</span> futures</span><br><span class="line">        print(results)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 同步任务通过执行器异步化</span></span><br><span class="line"><span class="decorator">    @tornado.concurrent.run_on_executor</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">(self, sec)</span>:</span></span><br><span class="line">        time.sleep(sec)</span><br><span class="line">        <span class="keyword">return</span> time.time()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app = tornado.web.Application([(<span class="string">r"/"</span>, AsyncHandler)])</span><br><span class="line">    app.listen(<span class="number">8000</span>)</span><br><span class="line">    tornado.ioloop.IOLoop.current().start()</span><br></pre></td></tr></table></figure>
<p>启动Web服务后，访问<code>/</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jzqt@Dreamer:~$ curl localhost:<span class="number">8000</span>/</span><br><span class="line">[<span class="number">1467202920.2401285</span>, <span class="number">1467202920.240263</span>, <span class="number">1467202920.2402115</span>, <span class="number">1467202920.2403257</span>, <span class="number">1467202921.240244</span>, <span class="number">1467202921.2412646</span>, <span class="number">1467202921.2413185</span>, <span class="number">1467202921.241381</span>]</span><br></pre></td></tr></table></figure>
<p>可以看出，同步任务确实是异步化了。上面的用例是通过线程池来异步的，更多的使用方法就不多讲了，可以研究官方文档等。</p>
<p><strong>注意</strong>：计算密集型任务使用线程优化作用不大，因为Python有GIL大家懂得。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在<code>Tornado</code>中，要使一个任务，我们经常需要用<code>Tornado</code>自己的异步模块，或者适配<code>Tornado</code>的第三方异步模块。</p>
<p>但很多情况下我们需要的功能模块可能没有适配<code>Torn]]>
    </summary>
    
      <category term="Python" scheme="http://jzqt.github.io/tags/Python/"/>
    
      <category term="Tornado" scheme="http://jzqt.github.io/tags/Tornado/"/>
    
      <category term="程序设计" scheme="http://jzqt.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python中or和and运算的返回值问题]]></title>
    <link href="http://jzqt.github.io/2016/03/19/Python%E4%B8%ADor%E5%92%8Cand%E8%BF%90%E7%AE%97%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E9%97%AE%E9%A2%98/"/>
    <id>http://jzqt.github.io/2016/03/19/Python中or和and运算的返回值问题/</id>
    <published>2016-03-19T14:23:25.000Z</published>
    <updated>2016-07-03T10:00:09.611Z</updated>
    <content type="html"><![CDATA[<p>机缘巧合之下发现Python的<code>or</code>和<code>and</code>运算后的返回值居然不是<code>bool</code>类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="string">'yes'</span> <span class="keyword">or</span> <span class="string">'no'</span></span><br><span class="line"><span class="string">'yes'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">0</span> <span class="keyword">or</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="string">'yes'</span> <span class="keyword">and</span> <span class="string">'no'</span></span><br><span class="line"><span class="string">'no'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">1</span> <span class="keyword">and</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">0</span> <span class="keyword">and</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>显然，<code>x and y and z and ...</code>运算遇到第一个布尔值为<strong>假</strong>的变量返回，如果没有则返回最后一个变量，<br><code>x or y or z or ...</code>运算遇到第一个布尔值为<strong>真</strong>的变量返回，如果没有也返回最后一个变量。</p>
<p>在我们的认知中，一般逻辑运算的结果就只有<code>True</code>和<code>False</code>，而Python逻辑运算这样的特性对我们Python编程有什么样的影响呢？</p>
<p>在判断逻辑运算的结果方面，绝不能采用<code>is True</code>或<code>== True</code>等判断方式（当然，这样也是十分不Pythonic的，相信这样干的人几乎没有吧）。</p>
<p>这样的特性还可以改写一些Python的三目运算，比如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = b <span class="keyword">if</span> b <span class="keyword">else</span> c</span><br><span class="line"><span class="comment"># 可改写为</span></span><br><span class="line">a = b <span class="keyword">or</span> c</span><br><span class="line"></span><br><span class="line">a = b <span class="keyword">if</span> c <span class="keyword">else</span> d</span><br><span class="line"><span class="comment"># 改写为</span></span><br><span class="line">a = c <span class="keyword">and</span> b <span class="keyword">or</span> d    <span class="comment"># 这样改写的前提条件是b必须为真</span></span><br></pre></td></tr></table></figure>
<p>同样，你也可以根据<code>and</code>运算返回特性简写一些代码，不赘述。</p>
<p>这个特性还可以很好解决一些代码风格问题，比如</p>
<p>一般来说，不推荐让<code>list</code>，<code>dict</code>等这样的可变对象作为Python函数的默认参数，那么如果你想让这两个可变对象做参数默认值又不想违反这个代码风格要怎么办呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(arg=[])</span>:</span></span><br><span class="line">    <span class="comment"># do somethine</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 改写后的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(arg=None)</span>:</span></span><br><span class="line">    arg = arg <span class="keyword">or</span> []</span><br><span class="line">    <span class="comment"># do somethine</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>这样就充分解决了风格的统一问题，实际上类似这样利用Python逻辑运算返回值特性的写法，在Django代码中也有大量使用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>机缘巧合之下发现Python的<code>or</code>和<code>and</code>运算后的返回值居然不是<code>bool</code>类型。</p>
<figure class="highlight python"><table><tr><td class=]]>
    </summary>
    
      <category term="Python" scheme="http://jzqt.github.io/tags/Python/"/>
    
      <category term="程序设计" scheme="http://jzqt.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SQLAlchemy笔记]]></title>
    <link href="http://jzqt.github.io/2015/12/29/SQLAlchemy%E7%AC%94%E8%AE%B0/"/>
    <id>http://jzqt.github.io/2015/12/29/SQLAlchemy笔记/</id>
    <published>2015-12-29T09:29:04.000Z</published>
    <updated>2016-07-15T12:39:24.471Z</updated>
    <content type="html"><![CDATA[<p>用SQLAlchemy做ORM也有一段时间了，总结一下用过的一些地方。</p>
<h1 id="连接数据库">连接数据库</h1><p>SQLAlchemy通过一个url连接数据库，这个url包含了连接数据库相关的信息。</p>
<h2 id="数据库连接URL">数据库连接URL</h2><p>以MySQL为例，url的格式是<code>mysql+{driver}://{username}:{password}@{host}:{port}/{name}</code>，<br>其中<code>driver</code>是Python的数据库驱动，比如MySQL官方的数据库驱动<code>mysql-connector-python</code>，<code>driver</code>是<code>mysqlconnector</code>；<br><code>username</code>是数据库用户名；<code>password</code>是密码；<code>host</code>是数据库主机；<code>port</code>是数据库端口；<code>name</code>是数据库名。</p>
<h2 id="创建数据库引擎，元数据以及会话等">创建数据库引擎，元数据以及会话等</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine, MetaData</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</span><br><span class="line"></span><br><span class="line">db_url = <span class="string">"mysql+mysqlconnector://root:@localhost:3306/test"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过数据库连接url创建数据库引擎</span></span><br><span class="line"><span class="comment"># 如果想回显SQLAlchemy操作数据库的日志，设置echo=True</span></span><br><span class="line">engine = create_engine(db_url, echo=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过数据库引擎绑定元信息</span></span><br><span class="line">metadata = MetaData(engine)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过绑定数据库引擎获取数据库会话类</span></span><br><span class="line">Session = sessionmaker(bind=engine) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数据库会话</span></span><br><span class="line">session = Session()</span><br></pre></td></tr></table></figure>
<p>一个<code>Session</code>实例可以理解成一个数据库连接，通过它来操作数据库；<br>也可以将它理解成一个容器，各种对象的实例存储在其中。</p>
<h2 id="数据库连接池">数据库连接池</h2><p><strong>注意</strong>：以上的连接数据库方式获取数据库连接是使用默认的数据库连接池的，<br>如果不想使用数据库连接池的话可以用以下方式创建数据库引擎。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.pool <span class="keyword">import</span> NullPool </span><br><span class="line">db_url = <span class="string">"mysql+mysqlconnector://root:@localhost:3306/test"</span></span><br><span class="line"></span><br><span class="line">engine = create_engine(db_url, poolclass=NullPool)</span><br></pre></td></tr></table></figure>
<h1 id="操作数据库">操作数据库</h1><h2 id="声明映射">声明映射</h2><p>在数据库中定义一个数据表对应在Python代码中则是定义一个类（也就是通常所说的Model），要维持从类到表的关系，首先就要先声明一个映射。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有继承自`Base`的实体类都会自动映射数据表</span></span><br><span class="line">Base = declarative_base()</span><br></pre></td></tr></table></figure>
<p>然后就可以通过继承<code>Base</code>类来定义映射到数据表中的类了。</p>
<p><strong>注意</strong>：<code>declarative_base()</code>生成的类，该类的子类一般都必须与数据库中的一张表对应，<br>如果想扩充这个基类，让所有子类都能使用，可以用如下方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"></span><br><span class="line">Base = declarative_base()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseModel</span><span class="params">(Base)</span>:</span></span><br><span class="line">    </span><br><span class="line">    __abstract__ = <span class="keyword">True</span>     <span class="comment"># 这样BaseModel类就不用对应数据库中的表了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ... 扩充BaseModel类的方法或属性等</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h2 id="定义数据表模型">定义数据表模型</h2><p>现在尝试创建一个简单的数据表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Integer, String, Enum, Column</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"></span><br><span class="line">Base = declarative_base()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Base)</span>:</span></span><br><span class="line"></span><br><span class="line">    __tablename__ = <span class="string">"tb_student"</span>            <span class="comment"># 数据表名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 下面是各个字段</span></span><br><span class="line">    id = Column(Integer(), primary_key=<span class="keyword">True</span>)    <span class="comment"># `id`字段，整数类型，主键，整数类型的主键默认为自动增长</span></span><br><span class="line">    name = Column(String(<span class="number">30</span>), nullable=<span class="keyword">False</span>)   <span class="comment"># `name`字段，字符串类型，最大长度30，设置为NOT NULL</span></span><br><span class="line">    gender = Column(Enum(<span class="string">'male'</span>, <span class="string">'female'</span>))     <span class="comment"># `gender`字段，枚举类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p><code>Integer</code>，<code>String</code>，<code>Enum</code>等数据类型都是SQLAlchemy定义的，会根据使用的数据库不同而使用数据库中对应的类型，<br>你也可以使用特定数据库的特定类型，以MySQL为例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy.dialects.mysql <span class="keyword">import</span> INTEGER, ENUM, VARCHAR, TINYINT, TEXT, BLOB, DATETIME</span><br></pre></td></tr></table></figure>
<h2 id="创建和删除数据表">创建和删除数据表</h2><p>上面的代码只是声明这么一个类<code>Student</code>映射数据表<code>tb_student</code>，创建数据表的操作需要如下代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建所有定义的数据表，会在数据库中执行`CREATE TABLE ...`语句</span></span><br><span class="line"><span class="comment"># 已经存在的数据表不会做操作</span></span><br><span class="line">Base.metadata.create_all(engine)</span><br></pre></td></tr></table></figure>
<p>删除数据表也是一样的操作，值得一提的是，未在代码中定义的数据表和不存在的数据表是不会做删除操作的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除所有定义的数据表</span></span><br><span class="line">Base.metadata.drop_all(engine)</span><br></pre></td></tr></table></figure>
<h2 id="数据状态">数据状态</h2><p>以ORM方式来对数据库中的数据做增删查改操作是通过<code>Session</code>实例来完成的，<br>在学习了解如何以ORM方式操作数据之前首先我们要对数据的状态有个基本的了解。</p>
<p>首先在ORM中，数据库中的<strong>数据表</strong>对应于Python中的<strong>类</strong>，而<strong>数据表中的记录</strong>对应于<strong>类的实例对象</strong>。<br>因此，对数据表中的记录进行增删查改在Python中实际上就是对实例对象的操作。</p>
<p>数据实例对象有四种状态，分别是</p>
<ul>
<li><p>Transient - （瞬时的）</p>
<p>  表示该实例对象不在session中，当然也没有保存到数据库中，<br>  主键一般情况下为<code>None</code>（如果一个<strong>Persistent</strong>状态的对象进行事务回滚后虽然主键有值，但却是<strong>Transient</strong>状态）。</p>
</li>
<li><p>Pending - （挂起的）</p>
<p>  调用<code>session.add()</code>后，<strong>Transient</strong>状态的对象就会变成<strong>Pending</strong>状态的对象，这个时候它只是在<code>session</code>中，<br>  并没有保存到数据库，因此主键依旧为<code>None</code>。<br>  只有触发了<code>session.flush()</code>操作才会保存到数据库使得主键有值，比如查询操作就会触发flush。</p>
</li>
<li><p>Persistent - （持久的）</p>
<p>  <code>session</code>和数据库中都有对应的记录存在，为持久状态。</p>
</li>
<li><p>Detached - （游离的）</p>
<p>  数据库中可能有记录，但是<code>session</code>中不存在。对这种对象的操作不会触发任何SQL语句。</p>
</li>
</ul>
<p>要查看数据对象的状态可以用如下方式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> inspect</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>status = inspect(data_object)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>status.persistent</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p><a href="http://docs.sqlalchemy.org/en/rel_1_0/orm/session_state_management.html#session-object-states" target="_blank" rel="external">SQLAlchemy关于数据实例对象状态的官方文档</a></p>
<h2 id="数据的简单操作">数据的简单操作</h2><p>以下面的数据表为例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Integer, String, Enum, Column</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"></span><br><span class="line">Base = declarative_base()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(Base)</span>:</span></span><br><span class="line"></span><br><span class="line">    __tablename__ = <span class="string">'tb_user'</span></span><br><span class="line"></span><br><span class="line">    id = Column(Integer(), primary_key=<span class="keyword">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">30</span>), nullable=<span class="keyword">False</span>)</span><br><span class="line">    gender = Column(Enum(<span class="string">'male'</span>, <span class="string">'famale'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&lt;User(id=&#123;&#125;)&gt;"</span>.format(self.id)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>用<code>session</code>来表示数据库会话实例。</p>
<h3 id="查询操作">查询操作</h3><p>查询子句使用<code>session</code>的<code>.query()</code>方法来获取<code>Query</code>查询对象。<br>查询对象能够使用一些方法来对应一些查询子句，比如<code>.order_by()</code>，<code>.limit()</code>，<code>.filter()</code>等，高级的查询后面会专门讲。</p>
<p>查询对象有这么几种方法<code>.one()</code>，<code>.all()</code>，<code>.scalar()</code>，<code>.one_or_none()</code>，<code>.get()</code>，以及<code>.first()</code>等。<br>下面对这几个方法的用法及效果做简单解释。</p>
<ul>
<li><p><code>.all()</code></p>
<p>  返回查询到的所有的结果。<br>  这个方法比较危险的地方是，如果数据量大且没有使用<code>limit</code>子句限制的话，所有的结果都会加载到内存中。<br>  它返回的是一个<strong>列表</strong>，如果查询不到任何结果，返回的是空列表。</p>
</li>
<li><p><code>.first()</code></p>
<p>  返回查询到的第一个结果，<strong>如果没有查询到结果，返回<code>None</code></strong>。</p>
</li>
<li><p><code>.scalar()</code></p>
<p>  这个方法与<code>.one_or_none()</code>的效果一样。<br>  如果查询到很多结果，抛出<code>sqlalchemy.orm.exc.MultipleResultsFound</code>异常。<br>  如果只有一个结果，返回它，没有结果返回<code>None</code>。</p>
</li>
<li><p><code>.one()</code></p>
<p>  如果只能查询到一个结果，返回它，否则抛出异常。<br>  没有结果时抛<code>sqlalchemy.orm.exc.NoResultFound</code>，有超过一个结果时抛<code>sqlalchemy.orm.exc.MultipleResultsFound</code>。</p>
</li>
<li><p><code>.one_or_none()</code></p>
<p>  比起<code>.one()</code>来，区别只是查询不到任何结果时不再抛出异常而是返回<code>None</code>。</p>
</li>
<li><p><code>.get()</code></p>
<p>  这是个比较特殊的方法。它用于根据主键来返回查询结果，因此它有个参数就是要查询的对象的主键。<br>  如果没有该主键的结果返回<code>None</code>，否则返回这个结果。</p>
</li>
</ul>
<p>代码示例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询所有的User对象</span></span><br><span class="line">session.query(User).all()</span><br><span class="line"><span class="comment"># 查询按照主键升序排序后的第一个User对象</span></span><br><span class="line">session.query(User).order_by(User.id.asc()).first()</span><br><span class="line"><span class="comment"># 查询指定user_id为主键的对象</span></span><br><span class="line">session.query(User).get(user_id)</span><br><span class="line">session.query(User).filter(User.id == user_id).scalar()</span><br><span class="line">session.query(User).filter(User.id == user_id).one_or_none()</span><br><span class="line">session.query(User).filter(User.id == user_id).one()    <span class="comment"># 如果查询不到会抛出异常，前面三个查询不到只是返回None</span></span><br></pre></td></tr></table></figure>
<h3 id="增加操作">增加操作</h3><h3 id="删除操作">删除操作</h3><h3 id="修改操作">修改操作</h3>]]></content>
    <summary type="html">
    <![CDATA[<p>用SQLAlchemy做ORM也有一段时间了，总结一下用过的一些地方。</p>
<h1 id="连接数据库">连接数据库</h1><p>SQLAlchemy通过一个url连接数据库，这个url包含了连接数据库相关的信息。</p>
<h2 id="数据库连接URL">数据库连]]>
    </summary>
    
      <category term="ORM" scheme="http://jzqt.github.io/tags/ORM/"/>
    
      <category term="Python" scheme="http://jzqt.github.io/tags/Python/"/>
    
      <category term="SQLAlchemy" scheme="http://jzqt.github.io/tags/SQLAlchemy/"/>
    
      <category term="数据库" scheme="http://jzqt.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="备忘" scheme="http://jzqt.github.io/categories/%E5%A4%87%E5%BF%98/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用户数据库的设计]]></title>
    <link href="http://jzqt.github.io/2015/10/26/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
    <id>http://jzqt.github.io/2015/10/26/用户数据库的设计/</id>
    <published>2015-10-26T14:34:48.000Z</published>
    <updated>2015-11-05T15:01:57.845Z</updated>
    <content type="html"><![CDATA[<p>软件工程的老师上课说数据库中的用户数据表的主键要用自增的<code>user_id</code>做主键，而不要用<code>username</code>做主键。</p>
<p>这让我产生了一些疑问。</p>
<p>首先，用户登录时提供的账号信息必然是自选的字符串<code>username</code>，而不是整数类型的自增主键<code>user_id</code>。<br>我认为<code>username</code>与<code>user_id</code>其实都是具有唯一性约束的字段。因此<code>username</code>完全可以替代<code>user_id</code>的作用，所以<code>user_id</code>就显得没那么有必要了。<br>如果没有其他足够的理由（比如优化之类的，可能我还不知道这个理由）是不应该引进这么个“多余”的字段的。</p>
<p>带着这样的疑问，我询问了老师这么做的原因。</p>
<p>老师给出了这样的回答，<strong>节省存储</strong>。<br>因为用户的主表只是存储用户的基本信息，其他用户表需要以用户主表的主键作为外键来存储信息。</p>
<p>这么说来，的确是这个样子的。<br>使用<code>INTEGER UNSIGNED</code>类型来存储<code>user_id</code>作为用户分表的外键，比起使用<code>VARCHAR</code>类型的<code>username</code>做外键，显然要节省存储的多。<br>毕竟前者只占用4个字节的存储，而后者占用<code>username</code>长度+1个字节的存储，显然不会有几个人的<code>username</code>会设置成3个字母以内嘛。<br>而且，数据越多，数据表越多，节省的存储也就越大。</p>
<p>理由很充分嘛。于是我继续问老师还有没有别的原因，他没再回答。</p>
<p>但是我觉得原因肯定不仅仅是这个，毕竟大部分应用和算法都是<strong>以空间换时间</strong>。<br>以<code>user_id</code>应该有某种效率上的优势才对，虽然我现在认为看起来反而使用<code>user_id</code>效率反而应该低些。</p>
<p>理由是：用户登录提供的是<code>username</code>，因此，如果用户主表是以<code>user_id</code>作为主键，那么应用需要通过登录用户提供的<code>username</code>在用户主表中查询出<code>user_id</code>，然后在用户分表中通过在用户主表查询出来的<code>user_id</code>来查询用户其他相关信息。<br>而如果直接采用<code>username</code>的话，不需要在用户主表做查询了，直接就可以拿着<code>username</code>在各种用户分表查各种用户信息。</p>
<p>当然，上面的理由其实都是我的一种猜测而已，正确的学习习惯是<strong>学习不能够想当然</strong>，因此，猜测归猜测，终归还是要验证的。</p>
<p>我只好找了一位已在工作中的前辈（外校的一个学长，帮助我解决了许多问题）询问这个问题。</p>
<p>在我与他的讨论中，他给出了如下的回答：</p>
<ol>
<li>老师说的没错，确实是能够节省存储</li>
<li>通常实践中也确实是使用整数类型的<code>user_id</code>来做主键的</li>
<li>整数字段做主键更加易于分表</li>
<li>自增主键比起字符串做索引，效率更高（看，果然有效率的问题哈）</li>
<li><code>username</code>这个东西过于偏向业务，如果今后系统还需要允许邮箱登录，手机号登录呢？</li>
</ol>
<p>以上的回答我认为第3,4,5点是非常重要的原因。<br>3,4的原因可以归结为在效率上和分表操作性上确实比用<code>username</code>做主键要好；<br>5则说明了对于那种扩展登录的业务，使用里面任何一种登录方式的字段作为主键都不太合适。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>软件工程的老师上课说数据库中的用户数据表的主键要用自增的<code>user_id</code>做主键，而不要用<code>username</code>做主键。</p>
<p>这让我产生了一些疑问。</p>
<p>首先，用户登录时提供的账号信息必然是自选的字符串<code]]>
    </summary>
    
      <category term="Witcoder" scheme="http://jzqt.github.io/tags/Witcoder/"/>
    
      <category term="数据库" scheme="http://jzqt.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Witcoder开发之路" scheme="http://jzqt.github.io/categories/Witcoder%E5%BC%80%E5%8F%91%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于Python的一次小记]]></title>
    <link href="http://jzqt.github.io/2015/10/20/%E5%85%B3%E4%BA%8EPython%E7%9A%84%E4%B8%80%E6%AC%A1%E5%B0%8F%E8%AE%B0/"/>
    <id>http://jzqt.github.io/2015/10/20/关于Python的一次小记/</id>
    <published>2015-10-20T14:53:25.000Z</published>
    <updated>2015-10-20T17:09:38.862Z</updated>
    <content type="html"><![CDATA[<p>室友在寝室做题，突然问了一句：“1到10的平方和是多少？”</p>
<p>我正在写Witcoder的HTML，突然意识到这是一个装13的好机会。</p>
<p>“什么什么？你再说一遍？！”</p>
<p>“1到10的平方和是多少？”</p>
<p>“马上马上，你等一下……”</p>
<p>我快速在终端打开Python敲了下面的代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>sum([i * i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>)])</span><br><span class="line"><span class="number">385</span></span><br></pre></td></tr></table></figure>
<p>“385啊”</p>
<p>“哦……”</p>
<p>接下来我想要说的可能很多人都猜到了。</p>
<p><strong>人生苦短，我用Python。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>室友在寝室做题，突然问了一句：“1到10的平方和是多少？”</p>
<p>我正在写Witcoder的HTML，突然意识到这是一个装13的好机会。</p>
<p>“什么什么？你再说一遍？！”</p>
<p>“1到10的平方和是多少？”</p>
<p>“马上马上，你等一下……”]]>
    </summary>
    
      <category term="Python" scheme="http://jzqt.github.io/tags/Python/"/>
    
      <category term="杂记" scheme="http://jzqt.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
      <category term="杂记" scheme="http://jzqt.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[色彩的纠结（比赛训练状态标签）]]></title>
    <link href="http://jzqt.github.io/2015/10/20/%E8%89%B2%E5%BD%A9%E7%9A%84%E7%BA%A0%E7%BB%93%EF%BC%88%E6%AF%94%E8%B5%9B%E8%AE%AD%E7%BB%83%E7%8A%B6%E6%80%81%E6%A0%87%E7%AD%BE%EF%BC%89/"/>
    <id>http://jzqt.github.io/2015/10/20/色彩的纠结（比赛训练状态标签）/</id>
    <published>2015-10-20T04:17:08.000Z</published>
    <updated>2015-10-20T17:11:32.754Z</updated>
    <content type="html"><![CDATA[<p>Witcoder的比赛训练有三种状态。<br>分别是<code>未开始</code>，<code>进行中</code>和<code>已结束</code>。</p>
<p>可是，在选择颜色代表它们的时候，我们陷入了纠结。<br>下面是几种考虑的方案。</p>
<p><img src="http://7xnmm9.com1.z0.glb.clouddn.com/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE20151019152005.png" alt=""><img src="http://7xnmm9.com1.z0.glb.clouddn.com/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE20151019152503.png" alt=""><img src="http://7xnmm9.com1.z0.glb.clouddn.com/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE20151019152813.png" alt=""><img src="http://7xnmm9.com1.z0.glb.clouddn.com/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE20151019153135.png" alt=""></p>
<p>后面还有很多，就不按照颜色排列组合一一上图了。反正就是这样。</p>
<p>对于<code>已结束</code>这个标签，基本是比较好选择的。最开始我们选择的是红色的标签。后来我们看了下Bootstrap里面的标签，发现其实还有个灰色的默认标签。我觉得可能灰色更加好，因为<strong>红色的标签感觉给人以强调，禁止，重点的意思</strong>，而<strong>灰色给人以沉闷，没有生机的感觉</strong>，正好能匹配<code>已结束</code>的意思。<br>这个搭配在团队里有获得一致的认可。</p>
<p><code>进行中</code>这个标签稍微有一点点争议，到底是选择蓝色还是绿色还真不好说。我对自己的审美一向都不敢恭维，选择蓝色感觉标签能更加清楚直接地被看到，而选择绿色，从逻辑上来说，<strong>绿色有通行，成功的意味</strong>，正好只有在比赛训练状态在<code>进行中</code>的时候才可以开始做题。<br>最后选择还是使用绿色标签来表示<code>进行中</code>，毕竟感觉<strong>逻辑</strong>才是最重要的，一群理科生啊唉。</p>
<p><code>未开始</code>是最坑爹的了。完全不知道该选什么，对于该什么颜色的逻辑也是非常不明确的。最后我暂定为淡蓝色。毕竟<code>未开始</code>我想应该用淡一点的颜色吧（我也不知道这是什么想法）。</p>
<p>虽然过程波折重重，总的来说团队成员都没有什么异议。最后颜色就暂定为这样。<br><img src="http://7xnmm9.com1.z0.glb.clouddn.com/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE20151019152005.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Witcoder的比赛训练有三种状态。<br>分别是<code>未开始</code>，<code>进行中</code>和<code>已结束</code>。</p>
<p>可是，在选择颜色代表它们的时候，我们陷入了纠结。<br>下面是几种考虑的方案。</p>
<p><img ]]>
    </summary>
    
      <category term="Witcoder" scheme="http://jzqt.github.io/tags/Witcoder/"/>
    
      <category term="杂记" scheme="http://jzqt.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
      <category term="Witcoder开发之路" scheme="http://jzqt.github.io/categories/Witcoder%E5%BC%80%E5%8F%91%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一个像素的问题]]></title>
    <link href="http://jzqt.github.io/2015/10/20/%E4%B8%80%E4%B8%AA%E5%83%8F%E7%B4%A0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://jzqt.github.io/2015/10/20/一个像素的问题/</id>
    <published>2015-10-20T04:15:54.000Z</published>
    <updated>2015-10-20T17:12:44.810Z</updated>
    <content type="html"><![CDATA[<p>下面这个故事，需要眼睛好点的人才能看懂（并不是说近视眼就算眼睛不好，主要是要眼尖，比如我虽然近视，但是眼尖）。</p>
<h2 id="开始">开始</h2><p><img src="http://7xnmm9.com1.z0.glb.clouddn.com/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE20151019202659.png" alt="1px"></p>
<p>上面是Witcoder的导航栏。看到了没有？有没有发现？<br>没错，首页的下面有一个像素的线没有被染成和首页一样的灰色！（看不出来的眼睛都不尖～～）<br>其实这个问题很久以前我就注意到了，奈何一直没有办法解决（虽然我号称全栈，其实也不过就是个会写简单HTML套Bootstrap的后端而已啦）。</p>
<p>是可忍孰不可忍，这次我下了决心一定要把这个问题解决，于是我叫了我们团队负责前端的小龙（这货其实会做页面精细的修改但是居然不会套前端模板，无法理解）……</p>
<h2 id="波折">波折</h2><p>其实小龙也无法独自解决这个坑爹的问题，但是正好我们打算把这个导航栏换个颜色，与网站整体颜色搭配。</p>
<p>于是，导航栏就变成了这样。<br><img src="http://7xnmm9.com1.z0.glb.clouddn.com/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE20151019205032.png" alt=""><br>看到了吗？发现了吗？那个<strong>1px</strong>的问题解决了！！！</p>
<p>可是，好景不长，我们发现阿飞写的宣传页面居然…<br><img src="http://7xnmm9.com1.z0.glb.clouddn.com/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE20151019210726.png" alt=""></p>
<p>谁叫他写的页面主体颜色是青色的呢…<br>其他页面都跟前面那张图一样没有问题，于是我和小龙一致认为是阿飞单独写的这个页面有问题，于是我和小龙打算修改阿飞写的宣传页面。</p>
<p>接下来各种研究原因研究HTML代码，无果。<br>小龙大胆猜想可能不是阿飞写的页面的问题，而是我们写的导航栏问题，只是因为其他页面的主体背景颜色是白色，所以没显示出来。</p>
<p>于是我将其他页面的背景颜色修改成了黑色。效果变成了这样<br><img src="http://7xnmm9.com1.z0.glb.clouddn.com/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE20151019211608.png" alt=""></p>
<p>错怪阿飞了有木有？！</p>
<h2 id="后来">后来</h2><p>好了，现在把这个bug定位到我们写的导航条了，我们仔细分析发现<br><img src="http://7xnmm9.com1.z0.glb.clouddn.com/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE20151019221015.png" alt=""></p>
<p><strong>Shit！怎么会有这么51这种坑爹的高度！！！</strong><br><img src="http://7xnmm9.com1.z0.glb.clouddn.com/u=2924251397,200844675&amp;fm=21&amp;gp=0.jpg" alt=""></p>
<p>于是我们开始用强的了！<br><img src="http://7xnmm9.com1.z0.glb.clouddn.com/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE20151019221335.png" alt=""></p>
<p>结果<br><img src="http://7xnmm9.com1.z0.glb.clouddn.com/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE20151019221641.png" alt=""><br>还是TMD有缝！而且…<br><img src="http://7xnmm9.com1.z0.glb.clouddn.com/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE20151019221800.png" alt=""><br>高度却成功更改了……<br>我的心情是这样的<br><img src="http://7xnmm9.com1.z0.glb.clouddn.com/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE20151019223230.png" alt=""></p>
<h2 id="最终">最终</h2><p>不过仔细地无意地，我们发现<br><img src="http://7xnmm9.com1.z0.glb.clouddn.com/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE20151019223351.png" alt=""><br>原来是特么导航条右边的按钮有问题呀呀呀！！！</p>
<p>接下来就不用多说了。</p>
<p>至此，这个问题现在终于被完美解决了……</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>下面这个故事，需要眼睛好点的人才能看懂（并不是说近视眼就算眼睛不好，主要是要眼尖，比如我虽然近视，但是眼尖）。</p>
<h2 id="开始">开始</h2><p><img src="http://7xnmm9.com1.z0.glb.clouddn.com/%E6%B7%]]>
    </summary>
    
      <category term="Witcoder" scheme="http://jzqt.github.io/tags/Witcoder/"/>
    
      <category term="杂记" scheme="http://jzqt.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
      <category term="Witcoder开发之路" scheme="http://jzqt.github.io/categories/Witcoder%E5%BC%80%E5%8F%91%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Witcoder开发之路]]></title>
    <link href="http://jzqt.github.io/2015/10/20/Witcoder%E5%BC%80%E5%8F%91%E4%B9%8B%E8%B7%AF/"/>
    <id>http://jzqt.github.io/2015/10/20/Witcoder开发之路/</id>
    <published>2015-10-20T04:10:28.000Z</published>
    <updated>2015-10-20T17:11:45.802Z</updated>
    <content type="html"><![CDATA[<p>想做一个Virtual Judge网站。<br>从大二的寒假这个想法开始萌芽到现在大三将它作为软件工程的实践项目来立项，已经有一个多学期了。</p>
<p>这一个多学期我都在步步准备，我当初简单想做个VJ的想法也在步步完善。<br>现在已经成功在软件工程课中将它作为实践项目，可以光明正大正正经经和小伙伴们一起实现自己的想法了。<br>这个软件工程课的开始就是Witcoder的开始，但是这个课的结束绝不是Witcoder的结束。</p>
<p>从开始立项到现在为止已经有四周了，开发的过程中有很多有趣的事情，所以我打算写些文章将它们记录下来。</p>
<p>恩，这个系列就叫做<code>Witcoder开发之路</code>好了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>想做一个Virtual Judge网站。<br>从大二的寒假这个想法开始萌芽到现在大三将它作为软件工程的实践项目来立项，已经有一个多学期了。</p>
<p>这一个多学期我都在步步准备，我当初简单想做个VJ的想法也在步步完善。<br>现在已经成功在软件工程课中将它作为实践项目]]>
    </summary>
    
      <category term="Witcoder" scheme="http://jzqt.github.io/tags/Witcoder/"/>
    
      <category term="杂记" scheme="http://jzqt.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
      <category term="Witcoder开发之路" scheme="http://jzqt.github.io/categories/Witcoder%E5%BC%80%E5%8F%91%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ACM图论之存图方式]]></title>
    <link href="http://jzqt.github.io/2015/07/21/ACM%E5%9B%BE%E8%AE%BA%E4%B9%8B%E5%AD%98%E5%9B%BE%E6%96%B9%E5%BC%8F/"/>
    <id>http://jzqt.github.io/2015/07/21/ACM图论之存图方式/</id>
    <published>2015-07-20T16:00:00.000Z</published>
    <updated>2015-10-20T17:11:06.818Z</updated>
    <content type="html"><![CDATA[<p>对于ACM图论方面的题目总是免不了首先要建图存图，使用合适的存图方式不但是AC的必要条件，解题事半功倍。</p>
<p>以下主要分析三种常见的存图方式的优缺点以及代码实现</p>
<ul>
<li>邻接矩阵</li>
<li>邻接表</li>
<li>链式前向星</li>
</ul>
<h1 id="邻接矩阵">邻接矩阵</h1><p><strong>邻接矩阵</strong>是三种存图方式中最<strong>简单</strong>也最为<strong>暴力</strong>的一种存图方式了。</p>
<h2 id="存图思想">存图思想</h2><p>使用一个矩阵来描述一个图，对于矩阵的第<code>i</code>行第<code>j</code>列的值，表示编号为<code>i</code>的顶点到编号为<code>j</code>的顶点的权值。</p>
<h2 id="代码实现">代码实现</h2><p>对于邻接矩阵来说，它的代码实现都十分简单，二维数组就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大顶点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> V = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接矩阵的定义</span></span><br><span class="line"><span class="comment">// mat[i][j] 表示 顶点`i`到顶点`j`的权值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mat[V][V];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接矩阵的初始化操作</span></span><br><span class="line"><span class="comment">// 假设权值为零表示没有该边</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(mat, <span class="number">0</span>, <span class="keyword">sizeof</span>(mat))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加边</span></span><br><span class="line"><span class="comment">// 新增顶点`i`到顶点`j`的边，权值为`w`</span></span><br><span class="line"></span><br><span class="line">mat[i][j] = w;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除边</span></span><br><span class="line"><span class="comment">// 删除顶点`i`到顶点`j`的边</span></span><br><span class="line"></span><br><span class="line">mat[i][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询边</span></span><br><span class="line"><span class="comment">// 查询顶点`i`到顶点`j`的边权</span></span><br><span class="line"></span><br><span class="line">mat[i][j];</span><br></pre></td></tr></table></figure>
<h2 id="优点">优点</h2><p>使用邻接矩阵来进行建图存图有以下优点</p>
<ul>
<li><p><strong>简单易学</strong></p>
<p>  这个肯定不用多说，哪怕是没学过线性代数的童鞋也很容易理解这样的存图方式。</p>
</li>
<li><p><strong>代码易写，简单好操作</strong></p>
<p>  上面的代码实现已经展示了要定义这个数据结构以及实现初始化，增加删除边等操作有多么的简单。</p>
</li>
<li><p><strong>对已确定的边进行操作，效率高</strong></p>
<p>  确定边（已知两顶点编号）要进行增加或删除边（或者说更改边权）以及查询边权等操作，时间复杂度为$O(1)$。</p>
</li>
<li><p><strong>易处理重边</strong></p>
<p>  你可以随时覆盖掉重边，可以自己实现存储最新的边，权值最大的边或权值最小的边等。<br>  当然，如果你非要使用邻接矩阵存图还要存重边也不是不可以。</p>
</li>
</ul>
<h2 id="缺点">缺点</h2><p>邻接矩阵存图虽然简单优雅，但是它的一些缺点却几乎是致命的。</p>
<ul>
<li><p><strong>过高的空间复杂度</strong></p>
<p>  对于顶点数<code>V</code>，邻接矩阵存图的<strong>空间复杂度高达$O(V^2)$</strong>，<strong>顶点数</strong>上了<strong>一万</strong>可以不用考虑这种存图方式了。<br>  <strong>对于稀疏图来说，邻接矩阵存图内存浪费太严重，这也是邻接矩阵存图在ACM题目中十分罕见的根本原因。</strong></p>
</li>
<li><p><strong>对于不确定边的查询效率一般</strong></p>
<p>  比如，我找个编号为<code>1</code>出发的第一条边我还要一条条边判断是否存在（权值是否为<code>0</code>）。</p>
</li>
</ul>
<h1 id="邻接表">邻接表</h1><p>邻接表在三种常用的存图方式中属于较为<strong>中庸</strong>和普遍的存图方式了，缺点不致命，优点不明显。</p>
<h2 id="存图思想-1">存图思想</h2><p><strong>邻接矩阵</strong>对于每个顶点使用<strong>定长的数组</strong>来存储以该点出发的边的情况。第<code>i</code>个数组的第<code>j</code>个值存储的是从顶点<code>i</code>到顶点<code>j</code>的边的权值。<br>而<strong>邻接表</strong>则是对于每个顶点使用<strong>不定长的链表</strong>来存储以该点出发的边的情况。因此对于第<code>i</code>个链表的第<code>j</code>个值实际上存储的是从编号为<code>i</code>的顶点出发的第<code>j</code>条边的情况。</p>
<p><strong>一般来说，如果有边权的话，邻接表的链表存储的是一个结构体，这个结构体存储该边的终点以及边权。</strong></p>
<p>下面给个邻接表与邻接矩阵存图的示例比较。</p>
<img src="/2015/07/21/ACM图论之存图方式/links&matrix.png" alt="links&matrix.png" title="">
<h2 id="代码实现-1">代码实现</h2><p>在ACM题目中，动态的数据结构一般是不被推荐的，因为动态开辟内存比较消耗时间，且写起来复杂容易出错。<br>大部分情况我们使用C++STL里的<code>vector</code>作为链表来实现图的邻接表。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大顶点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> V = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// vector实现的邻接表的定义</span></span><br><span class="line"><span class="comment">// 不考虑边权，存储类型为int型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; e[V];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表的初始化操作</span></span><br><span class="line"><span class="comment">// 将起点为`i`的边链表全部清空</span></span><br><span class="line"></span><br><span class="line">e[i].clear();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加边</span></span><br><span class="line"><span class="comment">// 新增顶点`i`到顶点`j`的边</span></span><br><span class="line"></span><br><span class="line">e[i].push_back(j);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询边</span></span><br><span class="line"></span><br><span class="line">e[i][<span class="number">0</span>];    <span class="comment">// 查询以`i`为起点的第一条边`i-&gt;e[i][0]`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;(<span class="keyword">int</span>)e[i].size(); ++j) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e[i][j] == k) &#123;     <span class="comment">// 查询边`i-&gt;k`</span></span><br><span class="line">        <span class="comment">// do something.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优点-1">优点</h2><ul>
<li><p><strong>较为简单易学</strong></p>
<p>  相比邻接矩阵，无非是数组转链表加上存储值的意义不同而已，不需要转太大的弯。</p>
</li>
<li><p><strong>代码易写，不复杂</strong></p>
<p>  代码实现已经演示过了，较简单，不容易写错。</p>
</li>
<li><p><strong>内存利用率高</strong></p>
<p>  对于顶点数<code>V</code>与边数<code>E</code>，<strong>空间复杂度为$O(V+E)$</strong>。能较好处理稀疏图的存储。</p>
</li>
<li><p><strong>对不确定边的操作方便效率也不错</strong></p>
<p>  比如，要遍历从某点出发的所有边，不会像邻接矩阵一样可能会遍历到不存在的边。</p>
</li>
</ul>
<h2 id="缺点-1">缺点</h2><ul>
<li><p><strong>重边不好处理</strong></p>
<p>  <strong>判重比较麻烦</strong>，还要遍历已有的边，不能直接判断。<br>  一般情况下使用邻接表存图是会存储重边的，不会做重边的判断。<br>  所以如果要解决重边的影响一般不在存边的情况下做文章。</p>
</li>
<li><p><strong>对确定边的操作效率不高</strong></p>
<p>  比如对于给定<code>i-&gt;j</code>的边要进行查询或修改等操作只有通过遍历这种方式找到了。</p>
</li>
</ul>
<h1 id="链式前向星">链式前向星</h1><p>未完待续……</p>
<h1 id="总结">总结</h1><p>对于<strong>邻接矩阵存图</strong>来说，由于<strong>内存消耗</strong>的局限性，它的<strong>适用范围十分狭窄</strong>，几乎只能在简单图论题目中见到。</p>
<p><strong>邻接表存图</strong>是<strong>最为常见</strong>的一种，绝大部分采用C++STL中的<code>vector</code>实现，一般情况下几乎所有图论题目都能使用该存图方式。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>对于ACM图论方面的题目总是免不了首先要建图存图，使用合适的存图方式不但是AC的必要条件，解题事半功倍。</p>
<p>以下主要分析三种常见的存图方式的优缺点以及代码实现</p>
<ul>
<li>邻接矩阵</li>
<li>邻接表</li>
<li>链式前向星</li>
]]>
    </summary>
    
      <category term="ACM" scheme="http://jzqt.github.io/tags/ACM/"/>
    
      <category term="图论" scheme="http://jzqt.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="算法与数据结构" scheme="http://jzqt.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法与数据结构" scheme="http://jzqt.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Markdown中写数学公式]]></title>
    <link href="http://jzqt.github.io/2015/06/30/Markdown%E4%B8%AD%E5%86%99%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"/>
    <id>http://jzqt.github.io/2015/06/30/Markdown中写数学公式/</id>
    <published>2015-06-30T06:58:13.000Z</published>
    <updated>2015-10-20T17:10:41.650Z</updated>
    <content type="html"><![CDATA[<p>一些扩展的<code>Markdown</code>语法支持采用<code>LaTex</code>语法写数学公式，而在网页中使用<code>Mathjax</code>插件来显示数学公式。</p>
<p>本教程介绍<strong>如何在Markdown中书写数学公式</strong>。</p>
<h1 id="插入数学公式">插入数学公式</h1><p>在Markdown中插入数学公式的语法是<code>$数学公式$</code>和<code>$$数学公式$$</code>。</p>
<p><strong>行内公式</strong>是可以让公式在文中与文字或其他东西混编，不独占一行。</p>
<ul>
<li><p><strong>示例</strong></p>
  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">质能方程$E = mc^2$</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>显示</strong></p>
<blockquote>
<p>质能方程$E = mc^2$</p>
</blockquote>
</li>
</ul>
<p><strong>独立公式</strong>使公式单独占一行，不与文中其他文字等混编。</p>
<ul>
<li><p><strong>示例</strong></p>
  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">质能方程$$E = mc^2$$</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>显示</strong></p>
<blockquote>
<p>质能方程$$E = mc^2$$</p>
</blockquote>
</li>
</ul>
<h1 id="普通公式">普通公式</h1><p>普通的加减乘除数学公式的输入方法与平常的书写一样。</p>
<ul>
<li><p><strong>示例</strong></p>
  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$x = 100 * y + z - 10 / 33 + 10 % 3$$</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>显示</strong></p>
<blockquote>
<p>$$x = 100 * y + z - 10 / 33 + 10 % 3$$</p>
</blockquote>
</li>
</ul>
<h1 id="上下标">上下标</h1><p>使用<code>^</code>来表示上标，<code>_</code>来表示下标，同时如果上下标的内容多于一个字符，可以使用<code>{}</code>来将这些内容括起来当做一个整体。<br>与此同时，上下标是可以嵌套的。</p>
<ul>
<li><p><strong>示例</strong></p>
  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$x = a<span class="emphasis">_&#123;1&#125;^n + a_</span>&#123;2&#125;^n + a_&#123;3&#125;^n$$</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>显示</strong></p>
<blockquote>
<p>$$x = a_{1}^n + a_{2}^n + a_{3}^n$$</p>
</blockquote>
</li>
</ul>
<p>如果希望左右两边都能有上下标，可以使用<code>\sideset</code>语法</p>
<ul>
<li><p><strong>示例</strong></p>
  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\sideset&#123;^1<span class="emphasis">_2&#125;&#123;^3_</span>4&#125;A$$</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>显示</strong></p>
<blockquote>
<p>$$\sideset{^1_2}{^3_4}A$$</p>
</blockquote>
</li>
</ul>
<h1 id="括号">括号</h1><p><code>()</code>，<code>[]</code>和<code>|</code>都表示它们自己，但是<code>{}</code>因为有特殊作用因此当需要显示大括号时一般使用<code>\lbrace \rbrace</code>来表示。</p>
<ul>
<li><p><strong>示例</strong></p>
  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$f(x, y) = 100 <span class="bullet">* \lbrace[(x + y) *</span> 3] - 5\rbrace$$</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>显示</strong></p>
<blockquote>
<p>$$f(x, y) = 100 * \lbrace[(x + y) * 3] - 5\rbrace$$</p>
</blockquote>
</li>
</ul>
<h1 id="分数">分数</h1><p>分数使用<code>\frac{分母}{分子}</code>这样的语法，不过推荐使用<code>\cfrac</code>来代替<code>\frac</code>，显示公式不会太挤。</p>
<ul>
<li><p><strong>示例</strong></p>
  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\frac&#123;1&#125;&#123;3&#125; 与 \cfrac&#123;1&#125;&#123;3&#125;$$</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>显示</strong></p>
<blockquote>
<p>$$\frac{1}{3} 与 \cfrac{1}{3}$$</p>
</blockquote>
</li>
</ul>
<h1 id="开方">开方</h1><p>开方使用<code>\sqrt[次数]{被开方数}</code>这样的语法</p>
<ul>
<li><p><strong>示例</strong></p>
  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$$\sqrt[3]&#123;X&#125;$$</span><br><span class="line">$$\sqrt&#123;5 - x&#125;$$</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>显示</strong></p>
<blockquote>
<p>$$\sqrt[3]{X}$$<br>$$\sqrt{5 - x}$$</p>
</blockquote>
</li>
</ul>
<h1 id="希腊字母">希腊字母</h1><p>见下表</p>
<table>
<thead>
<tr>
<th style="text-align:center">代码</th>
<th style="text-align:center">大写</th>
<th style="text-align:center">代码</th>
<th style="text-align:left">小写</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>A</code></td>
<td style="text-align:center">$A$</td>
<td style="text-align:center"><code>\alpha</code></td>
<td style="text-align:left">$\alpha$</td>
</tr>
<tr>
<td style="text-align:center"><code>B</code></td>
<td style="text-align:center">$B$</td>
<td style="text-align:center"><code>\beta</code></td>
<td style="text-align:left">$\beta$</td>
</tr>
<tr>
<td style="text-align:center"><code>\Gamma</code></td>
<td style="text-align:center">$\Gamma$</td>
<td style="text-align:center"><code>\gamma</code></td>
<td style="text-align:left">$\gamma$</td>
</tr>
<tr>
<td style="text-align:center"><code>\Delta</code></td>
<td style="text-align:center">$\Delta$</td>
<td style="text-align:center"><code>\delta</code></td>
<td style="text-align:left">$\delta$</td>
</tr>
<tr>
<td style="text-align:center"><code>E</code></td>
<td style="text-align:center">$E$</td>
<td style="text-align:center"><code>\epsilon</code></td>
<td style="text-align:left">$\epsilon$</td>
</tr>
<tr>
<td style="text-align:center"><code>Z</code></td>
<td style="text-align:center">$Z$</td>
<td style="text-align:center"><code>\zeta</code></td>
<td style="text-align:left">$\zeta$</td>
</tr>
<tr>
<td style="text-align:center"><code>H</code></td>
<td style="text-align:center">$H$</td>
<td style="text-align:center"><code>\eta</code></td>
<td style="text-align:left">$\eta$</td>
</tr>
<tr>
<td style="text-align:center"><code>\Theta</code></td>
<td style="text-align:center">$\Theta$</td>
<td style="text-align:center"><code>\theta</code></td>
<td style="text-align:left">$\theta$</td>
</tr>
<tr>
<td style="text-align:center"><code>I</code></td>
<td style="text-align:center">$I$</td>
<td style="text-align:center"><code>\iota</code></td>
<td style="text-align:left">$\iota$</td>
</tr>
<tr>
<td style="text-align:center"><code>K</code></td>
<td style="text-align:center">$K$</td>
<td style="text-align:center"><code>\kappa</code></td>
<td style="text-align:left">$\kappa$</td>
</tr>
<tr>
<td style="text-align:center"><code>\Lambda</code></td>
<td style="text-align:center">$\Lambda$</td>
<td style="text-align:center"><code>\lambda</code></td>
<td style="text-align:left">$\lambda$</td>
</tr>
<tr>
<td style="text-align:center"><code>M</code></td>
<td style="text-align:center">$M$</td>
<td style="text-align:center"><code>\mu</code></td>
<td style="text-align:left">$\mu$</td>
</tr>
<tr>
<td style="text-align:center"><code>N</code></td>
<td style="text-align:center">$N$</td>
<td style="text-align:center"><code>\nu</code></td>
<td style="text-align:left">$\nu$</td>
</tr>
<tr>
<td style="text-align:center"><code>\Xi</code></td>
<td style="text-align:center">$\Xi$</td>
<td style="text-align:center"><code>\xi</code></td>
<td style="text-align:left">$\xi$</td>
</tr>
<tr>
<td style="text-align:center"><code>O</code></td>
<td style="text-align:center">$O$</td>
<td style="text-align:center"><code>\omicron</code></td>
<td style="text-align:left">$\omicron$</td>
</tr>
<tr>
<td style="text-align:center"><code>\Pi</code></td>
<td style="text-align:center">$\Pi$</td>
<td style="text-align:center"><code>\pi</code></td>
<td style="text-align:left">$\pi$</td>
</tr>
<tr>
<td style="text-align:center"><code>P</code></td>
<td style="text-align:center">$P$</td>
<td style="text-align:center"><code>\rho</code></td>
<td style="text-align:left">$\rho$</td>
</tr>
<tr>
<td style="text-align:center"><code>\Sigma</code></td>
<td style="text-align:center">$\Sigma$</td>
<td style="text-align:center"><code>\sigma</code></td>
<td style="text-align:left">$\sigma$</td>
</tr>
<tr>
<td style="text-align:center"><code>T</code></td>
<td style="text-align:center">$T$</td>
<td style="text-align:center"><code>\tau</code></td>
<td style="text-align:left">$\tau$</td>
</tr>
<tr>
<td style="text-align:center"><code>\Upsilon</code></td>
<td style="text-align:center">$\Upsilon$</td>
<td style="text-align:center"><code>\upsilon</code></td>
<td style="text-align:left">$\upsilon$</td>
</tr>
<tr>
<td style="text-align:center"><code>\Phi</code></td>
<td style="text-align:center">$\Phi$</td>
<td style="text-align:center"><code>\phi</code></td>
<td style="text-align:left">$\phi$</td>
</tr>
<tr>
<td style="text-align:center"><code>X</code></td>
<td style="text-align:center">$X$</td>
<td style="text-align:center"><code>\chi</code></td>
<td style="text-align:left">$\chi$</td>
</tr>
<tr>
<td style="text-align:center"><code>\Psi</code></td>
<td style="text-align:center">$\Psi$</td>
<td style="text-align:center"><code>\psi</code></td>
<td style="text-align:left">$\psi$</td>
</tr>
<tr>
<td style="text-align:center"><code>\Omega</code></td>
<td style="text-align:center">$\Omega$</td>
<td style="text-align:center"><code>\omega</code></td>
<td style="text-align:left">$\omega$</td>
</tr>
</tbody>
</table>
<h1 id="其他字符">其他字符</h1><h2 id="关系运算符">关系运算符</h2><table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:left">代码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\pm$</td>
<td style="text-align:left"><code>\pm</code></td>
</tr>
<tr>
<td style="text-align:center">$\times$</td>
<td style="text-align:left"><code>\times</code></td>
</tr>
<tr>
<td style="text-align:center">$\div$</td>
<td style="text-align:left"><code>\div</code></td>
</tr>
<tr>
<td style="text-align:center">$\mid$</td>
<td style="text-align:left"><code>\mid</code></td>
</tr>
<tr>
<td style="text-align:center">$\nmid$</td>
<td style="text-align:left"><code>\nmid</code></td>
</tr>
<tr>
<td style="text-align:center">$\cdot$</td>
<td style="text-align:left"><code>\cdot</code></td>
</tr>
<tr>
<td style="text-align:center">$\circ$</td>
<td style="text-align:left"><code>\circ</code></td>
</tr>
<tr>
<td style="text-align:center">$\ast$</td>
<td style="text-align:left"><code>\ast</code></td>
</tr>
<tr>
<td style="text-align:center">$\bigodot$</td>
<td style="text-align:left"><code>\bigodot</code></td>
</tr>
<tr>
<td style="text-align:center">$\bigotimes$</td>
<td style="text-align:left"><code>\bigotimes</code></td>
</tr>
<tr>
<td style="text-align:center">$\bigoplus$</td>
<td style="text-align:left"><code>\bigoplus</code></td>
</tr>
<tr>
<td style="text-align:center">$\leq$</td>
<td style="text-align:left"><code>\leq</code></td>
</tr>
<tr>
<td style="text-align:center">$\geq$</td>
<td style="text-align:left"><code>\geq</code></td>
</tr>
<tr>
<td style="text-align:center">$\neq$</td>
<td style="text-align:left"><code>\neq</code></td>
</tr>
<tr>
<td style="text-align:center">$\approx$</td>
<td style="text-align:left"><code>\approx</code></td>
</tr>
<tr>
<td style="text-align:center">$\equiv$</td>
<td style="text-align:left"><code>\equiv</code></td>
</tr>
<tr>
<td style="text-align:center">$\sum$</td>
<td style="text-align:left"><code>\sum</code></td>
</tr>
<tr>
<td style="text-align:center">$\prod$</td>
<td style="text-align:left"><code>\prod</code></td>
</tr>
<tr>
<td style="text-align:center">$\coprod$</td>
<td style="text-align:left"><code>\coprod</code></td>
</tr>
</tbody>
</table>
<h2 id="集合运算符">集合运算符</h2><table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:left">代码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\emptyset$</td>
<td style="text-align:left"><code>\emptyset</code></td>
</tr>
<tr>
<td style="text-align:center">$\in$</td>
<td style="text-align:left"><code>\in</code></td>
</tr>
<tr>
<td style="text-align:center">$\notin$</td>
<td style="text-align:left"><code>\notin</code></td>
</tr>
<tr>
<td style="text-align:center">$\subset$</td>
<td style="text-align:left"><code>\subset</code></td>
</tr>
<tr>
<td style="text-align:center">$\supset$</td>
<td style="text-align:left"><code>\supset</code></td>
</tr>
<tr>
<td style="text-align:center">$\subseteq$</td>
<td style="text-align:left"><code>\subseteq</code></td>
</tr>
<tr>
<td style="text-align:center">$\supseteq$</td>
<td style="text-align:left"><code>\supseteq</code></td>
</tr>
<tr>
<td style="text-align:center">$\bigcap$</td>
<td style="text-align:left"><code>\bigcap</code></td>
</tr>
<tr>
<td style="text-align:center">$\bigcup$</td>
<td style="text-align:left"><code>\bigcup</code></td>
</tr>
<tr>
<td style="text-align:center">$\bigvee$</td>
<td style="text-align:left"><code>\bigvee</code></td>
</tr>
<tr>
<td style="text-align:center">$\bigwedge$</td>
<td style="text-align:left"><code>\bigwedge</code></td>
</tr>
<tr>
<td style="text-align:center">$\biguplus$</td>
<td style="text-align:left"><code>\biguplus</code></td>
</tr>
<tr>
<td style="text-align:center">$\bigsqcup$</td>
<td style="text-align:left"><code>\bigsqcup</code></td>
</tr>
</tbody>
</table>
<h2 id="对数运算符">对数运算符</h2><table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:left">代码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\log$</td>
<td style="text-align:left"><code>\log</code></td>
</tr>
<tr>
<td style="text-align:center">$\lg$</td>
<td style="text-align:left"><code>\lg</code></td>
</tr>
<tr>
<td style="text-align:center">$\ln$</td>
<td style="text-align:left"><code>\ln</code></td>
</tr>
</tbody>
</table>
<h2 id="三角运算符">三角运算符</h2><table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:left">代码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\bot$</td>
<td style="text-align:left"><code>\bot</code></td>
</tr>
<tr>
<td style="text-align:center">$\angle$</td>
<td style="text-align:left"><code>\angle</code></td>
</tr>
<tr>
<td style="text-align:center">$\sin$</td>
<td style="text-align:left"><code>\sin</code></td>
</tr>
<tr>
<td style="text-align:center">$\cos$</td>
<td style="text-align:left"><code>\cos</code></td>
</tr>
<tr>
<td style="text-align:center">$\tan$</td>
<td style="text-align:left"><code>\tan</code></td>
</tr>
<tr>
<td style="text-align:center">$\cot$</td>
<td style="text-align:left"><code>\cot</code></td>
</tr>
<tr>
<td style="text-align:center">$\sec$</td>
<td style="text-align:left"><code>\sec</code></td>
</tr>
<tr>
<td style="text-align:center">$\csc$</td>
<td style="text-align:left"><code>\csc</code></td>
</tr>
</tbody>
</table>
<h2 id="微积分运算符">微积分运算符</h2><table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:left">代码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\prime$</td>
<td style="text-align:left"><code>\prime</code></td>
</tr>
<tr>
<td style="text-align:center">$\int$</td>
<td style="text-align:left"><code>\int</code></td>
</tr>
<tr>
<td style="text-align:center">$\iint$</td>
<td style="text-align:left"><code>\iint</code></td>
</tr>
<tr>
<td style="text-align:center">$\iiint$</td>
<td style="text-align:left"><code>\iiint</code></td>
</tr>
<tr>
<td style="text-align:center">$\iiiint$</td>
<td style="text-align:left"><code>\iiiint</code></td>
</tr>
<tr>
<td style="text-align:center">$\oint$</td>
<td style="text-align:left"><code>\oint</code></td>
</tr>
<tr>
<td style="text-align:center">$\lim$</td>
<td style="text-align:left"><code>\lim</code></td>
</tr>
<tr>
<td style="text-align:center">$\infty$</td>
<td style="text-align:left"><code>\infty</code></td>
</tr>
<tr>
<td style="text-align:center">$\nabla$</td>
<td style="text-align:left"><code>\nabla</code></td>
</tr>
<tr>
<td style="text-align:center">$\mathrm{d}$</td>
<td style="text-align:left"><code>\mathrm{d}</code></td>
</tr>
</tbody>
</table>
<h1 id="未完待续">未完待续</h1><p><strong>……</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一些扩展的<code>Markdown</code>语法支持采用<code>LaTex</code>语法写数学公式，而在网页中使用<code>Mathjax</code>插件来显示数学公式。</p>
<p>本教程介绍<strong>如何在Markdown中书写数学公式</s]]>
    </summary>
    
      <category term="LaTex" scheme="http://jzqt.github.io/tags/LaTex/"/>
    
      <category term="Markdown" scheme="http://jzqt.github.io/tags/Markdown/"/>
    
      <category term="Mathjax" scheme="http://jzqt.github.io/tags/Mathjax/"/>
    
      <category term="备忘" scheme="http://jzqt.github.io/categories/%E5%A4%87%E5%BF%98/"/>
    
  </entry>
  
</feed>
